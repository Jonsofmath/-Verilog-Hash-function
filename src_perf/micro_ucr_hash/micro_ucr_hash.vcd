$date
	Tue Jul 13 18:52:19 2021
$end
$version
	Icarus Verilog
$end
$timescale
	100ps
$end
$scope module test_bench $end
$var wire 1 ! reset $end
$var wire 8 " hash_array2 [7:0] $end
$var wire 8 # hash_array1 [7:0] $end
$var wire 8 $ hash_array0 [7:0] $end
$var wire 1 % clk $end
$var wire 8 & array_numbers9 [7:0] $end
$var wire 8 ' array_numbers8 [7:0] $end
$var wire 8 ( array_numbers7 [7:0] $end
$var wire 8 ) array_numbers6 [7:0] $end
$var wire 8 * array_numbers5 [7:0] $end
$var wire 8 + array_numbers4 [7:0] $end
$var wire 8 , array_numbers3 [7:0] $end
$var wire 8 - array_numbers2 [7:0] $end
$var wire 8 . array_numbers15 [7:0] $end
$var wire 8 / array_numbers14 [7:0] $end
$var wire 8 0 array_numbers13 [7:0] $end
$var wire 8 1 array_numbers12 [7:0] $end
$var wire 8 2 array_numbers11 [7:0] $end
$var wire 8 3 array_numbers10 [7:0] $end
$var wire 8 4 array_numbers1 [7:0] $end
$var wire 8 5 array_numbers0 [7:0] $end
$scope module COND $end
$var wire 1 ! reset $end
$var wire 1 % clk $end
$var wire 8 6 array_numbers9 [7:0] $end
$var wire 8 7 array_numbers8 [7:0] $end
$var wire 8 8 array_numbers7 [7:0] $end
$var wire 8 9 array_numbers6 [7:0] $end
$var wire 8 : array_numbers5 [7:0] $end
$var wire 8 ; array_numbers4 [7:0] $end
$var wire 8 < array_numbers3 [7:0] $end
$var wire 8 = array_numbers2 [7:0] $end
$var wire 8 > array_numbers15 [7:0] $end
$var wire 8 ? array_numbers14 [7:0] $end
$var wire 8 @ array_numbers13 [7:0] $end
$var wire 8 A array_numbers12 [7:0] $end
$var wire 8 B array_numbers11 [7:0] $end
$var wire 8 C array_numbers10 [7:0] $end
$var wire 8 D array_numbers1 [7:0] $end
$var wire 8 E array_numbers0 [7:0] $end
$var reg 8 F a [7:0] $end
$var reg 1 G a_b_c_flag $end
$var reg 8 H b [7:0] $end
$var reg 8 I c [7:0] $end
$var reg 6 J counter [5:0] $end
$var reg 1 K first_flag $end
$var reg 8 L hash_array0 [7:0] $end
$var reg 8 M hash_array1 [7:0] $end
$var reg 8 N hash_array2 [7:0] $end
$var reg 8 O hash_array_int_0 [7:0] $end
$var reg 8 P hash_array_int_1 [7:0] $end
$var reg 8 Q hash_array_int_2 [7:0] $end
$var reg 8 R k [7:0] $end
$var reg 1 S k_x_flag $end
$var reg 9 T last_flag [8:0] $end
$var reg 8 U w_debug [7:0] $end
$var reg 8 V x [7:0] $end
$var integer 32 W i [31:0] $end
$var integer 32 X j [31:0] $end
$upscope $end
$scope module TEST $end
$var wire 8 Y hash_array0 [7:0] $end
$var wire 8 Z hash_array1 [7:0] $end
$var wire 8 [ hash_array2 [7:0] $end
$var reg 8 \ array_numbers0 [7:0] $end
$var reg 8 ] array_numbers1 [7:0] $end
$var reg 8 ^ array_numbers10 [7:0] $end
$var reg 8 _ array_numbers11 [7:0] $end
$var reg 8 ` array_numbers12 [7:0] $end
$var reg 8 a array_numbers13 [7:0] $end
$var reg 8 b array_numbers14 [7:0] $end
$var reg 8 c array_numbers15 [7:0] $end
$var reg 8 d array_numbers2 [7:0] $end
$var reg 8 e array_numbers3 [7:0] $end
$var reg 8 f array_numbers4 [7:0] $end
$var reg 8 g array_numbers5 [7:0] $end
$var reg 8 h array_numbers6 [7:0] $end
$var reg 8 i array_numbers7 [7:0] $end
$var reg 8 j array_numbers8 [7:0] $end
$var reg 8 k array_numbers9 [7:0] $end
$var reg 1 % clk $end
$var reg 1 ! reset $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx k
bx j
bx i
bx h
bx g
bx f
bx e
bx d
bx c
bx b
bx a
bx `
bx _
bx ^
bx ]
bx \
b0 [
b0 Z
b0 Y
bx X
bx W
bx V
bx U
b0 T
0S
bx R
bx Q
bx P
bx O
b0 N
b0 M
b0 L
0K
b0 J
b0 I
b0 H
0G
b0 F
bx E
bx D
bx C
bx B
bx A
bx @
bx ?
bx >
bx =
bx <
bx ;
bx :
bx 9
bx 8
bx 7
bx 6
bx 5
bx 4
bx 3
bx 2
bx 1
bx 0
bx /
bx .
bx -
bx ,
bx +
bx *
bx )
bx (
bx '
bx &
0%
b0 $
b0 #
b0 "
0!
$end
#20
1%
#40
0%
#60
bx "
bx N
bx [
bx #
bx M
bx Z
bx $
bx L
bx Y
bx V
b10100001 R
bx I
bx0000 H
bx F
b100000 X
b11111110 Q
b10001001 P
b1 O
b100000 W
1!
1%
#80
0%
#100
1%
#120
0%
#140
1%
#160
0%
#180
1%
#200
0%
#220
1%
#240
0%
#260
b1110011 "
b1110011 N
b1110011 [
b10001001 #
b10001001 M
b10001001 Z
b11110001 $
b11110001 L
b11110001 Y
b11010101 V
b10100001 R
b1110101 I
b0 H
b11110000 F
b100000 X
b11111111 U
b100000 W
b111100 .
b111100 >
b111100 c
b10000111 /
b10000111 ?
b10000111 b
b11101101 0
b11101101 @
b11101101 a
b11111101 1
b11111101 A
b11111101 `
b100100 2
b100100 B
b100100 _
b110011 3
b110011 C
b110011 ^
b11111 &
b11111 6
b11111 k
b1101011 '
b1101011 7
b1101011 j
b1101100 (
b1101100 8
b1101100 i
b10011110 )
b10011110 9
b10011110 h
b11001010 *
b11001010 :
b11001010 g
b1000000 +
b1000000 ;
b1000000 f
b101111 ,
b101111 <
b101111 e
b10011111 -
b10011111 =
b10011111 d
b1111101 4
b1111101 D
b1111101 ]
b111001 5
b111001 E
b111001 \
1%
#280
0%
#300
1%
#320
0%
#340
1%
#360
0%
#380
1%
#400
0%
#420
1%
#440
0%
#460
1%
#480
0%
#500
1%
#520
0%
#540
1%
#560
0%
#580
1%
#600
0%
#620
1%
#640
0%
#660
1%
#680
0%
#700
1%
#720
0%
#740
1%
#760
0%
#780
1%
#800
0%
#820
1%
#840
0%
#860
1%
#880
0%
#900
1%
#920
0%
#940
1%
#960
0%
#980
1%
#1000
0%
#1020
1%
#1040
0%
#1060
1%
#1080
0%
#1100
1%
#1120
0%
#1140
1%
#1160
0%
#1180
1%
#1200
0%
#1220
1%
#1240
0%
#1260
1%
#1280
0%
#1300
1%
#1320
0%
#1340
b11010101 "
b11010101 N
b11010101 [
b1010001 $
b1010001 L
b1010001 Y
b11010101 V
b10100001 R
b11010111 I
b0 H
b1010000 F
b100000 X
b1100001 U
b100000 W
b1100001 .
b1100001 >
b1100001 c
b1100001 /
b1100001 ?
b1100001 b
b1100001 0
b1100001 @
b1100001 a
b1100001 1
b1100001 A
b1100001 `
b1100001 2
b1100001 B
b1100001 _
b1100001 3
b1100001 C
b1100001 ^
b1100001 &
b1100001 6
b1100001 k
b1100001 '
b1100001 7
b1100001 j
b1100001 (
b1100001 8
b1100001 i
b1100001 )
b1100001 9
b1100001 h
b1100001 *
b1100001 :
b1100001 g
b1100001 +
b1100001 ;
b1100001 f
b1100001 ,
b1100001 <
b1100001 e
b1100001 -
b1100001 =
b1100001 d
b1100001 4
b1100001 D
b1100001 ]
b1100001 5
b1100001 E
b1100001 \
1%
